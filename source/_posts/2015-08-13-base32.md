---
title: "base32 についてメモ"
date: 2015-08-13 21:48:14
tags:
  - others
---

base32 について調べた際のメモ書き。

特徴
----------------------------------------------------------------------
base32 は、base64 などと同様、バイナリ文字列とテキスト文字列の変換（エンコード or デコード）を行うアルゴリズム。

- エンコードされたテキスト文字列は、`A-Z`(26文字) と `2-7`(6文字)、`=` の 33文字で構成される。
- 大文字小文字の区別がない環境でも利用可能。
- エンコードは、40ビット(5文字)単位を、8文字に変換していく。
- 40ビットに満たない場合は、`=` パティングする。
- base32hex というのもあり、これは、`0-9`、`A-V`、`=` の33文字を使用する。

<!-- more -->

RFC
----------------------------------------------------------------------
- RFC 4648 http://tools.ietf.org/html/rfc4648.html
- RFC 3458 http://tools.ietf.org/html/rfc3548.html (Obsoletes)

対応表
----------------------------------------------------------------------

```
                     Table 3: The Base 32 Alphabet

     Value Encoding  Value Encoding  Value Encoding  Value Encoding
         0 A             9 J            18 S            27 3
         1 B            10 K            19 T            28 4
         2 C            11 L            20 U            29 5
         3 D            12 M            21 V            30 6
         4 E            13 N            22 W            31 7
         5 F            14 O            23 X
         6 G            15 P            24 Y         (pad) =
         7 H            16 Q            25 Z
         8 I            17 R            26 2
```
ref: http://tools.ietf.org/html/rfc4648#section-6

エンコード手順
----------------------------------------------------------------------
文字列`harasou`を base32 でエンコードしてみる。

大まかな流れとしては、2進表記にした文字列`harasou`を 5ビット単位に分割し、各分割した値を対応表に沿ってテキストに変換する。

1. 文字列`harasou`の 2進数表記
    - `01101000 01100001 01110010 01100001 01110011 01101111 01110101`

1. 40ビット単位に区切る。
    - `01101000 01100001 01110010 01100001 01110011`
    - `01101111 01110101`

1. 40ビット単位を 8分割する(5ビット単位にする)。最後が 5ビットに満たない場合は 0パディングする。
    - `01101` `00001` `10000` `10111` `00100` `11000` `01011` `10011`
    - `01101` `11101` `11010` `10000`

1. 分割した各値の10進表記
    - `13` `_1` `16` `23` `_4` `24` `11` `19`
    - `13` `29` `26` `16`

1. 分割した各値を対応表に沿ってテキストにする。
    - `N` `B` `Q` `X` `E` `Y` `L` `T`
    - `N` `5` `2` `Q`

1. 5バイト(40ビット)ちょうどで区切れなかった場合は、不足したバイト数に合わせた `=` パディングを行う。
    - `N` `B` `Q` `X` `E` `Y` `L` `T`
    - `N` `5` `2` `Q` `=` `=` `=` `=`

1. エンコード結果
    - `NBQXEYLTN52Q====`

補足
----------------------------------------------------------------------
`=`パディングについて補足すると、エンコード対象を 5バイト(40ビット)単位で区切った際に、最後の固まりが、

- 5バイトに 1バイト満たない場合、`=`を 1つ付加
- 5バイトに 2バイト満たない場合、`=`を 3つ付加
- 5バイトに 3バイト満たない場合、`=`を 4つ付加
- 5バイトに 4バイト満たない場合、`=`を 6つ付加

といった感じになる。

```
例）
     最後のかたまり -> エンコード結果
5バイト丁度： AAAAA -> IFAUCQKB
1バイト不足： AAAA_ -> IFAUCQI= (「=」を1つ付加)
2バイト不足： AAA__ -> IFAUC=== (「=」を3つ付加)
3バイト不足： AA___ -> IFAQ==== (「=」を4つ付加)
4バイト不足： A____ -> IE====== (「=」を6つ付加)
```

実装
----------------------------------------------------------------------
やってる処理は上のようなものだが、実装は様々。

- golang
    - https://golang.org/src/encoding/base32/base32.go

- ruby
    - https://github.com/stesla/base32/blob/master/lib/base32.rb

- php
    - http://php.net/manual/ja/function.base-convert.php#102232
    - base_convert() を利用

